<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Halftone Dots (white on transparent)</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 0; font-family: system-ui, Arial, sans-serif; display: grid; grid-template-columns: 320px 1fr; min-height: 100vh; }
  aside { padding: 16px; border-right: 1px solid #ddd; display: flex; flex-direction: column; gap: 12px; }
  main  { display: grid; place-items: center; background:
           repeating-conic-gradient(#bbb 0 25%, #eee 0 50%) 0 0/16px 16px; } /* шахматная подложка под прозрачность */
  canvas { max-width: 100%; max-height: 100vh; background: transparent; }
  h1 { font-size: 18px; margin: 0 0 8px; }
  .row { display: flex; align-items: center; gap: 8px; }
  .row input[type="range"] { width: 100%; }
  .hint { font-size: 12px; opacity: .75; }
  button { padding: 10px 12px; font-weight: 600; cursor: pointer; }
  .num { font-variant-numeric: tabular-nums; min-width: 48px; text-align: right; }
  label { display: grid; gap: 4px; }
</style>
</head>
<body>
  <aside>
    <h1>Halftone Dots</h1>

    <label>
      <b>1) Загрузите картинку</b>
      <input id="file" type="file" accept="image/*">
      <div class="hint">Изображение автоматически станет размером canvas</div>
    </label>

    <label>
      <b>Шаг решётки (px)</b>
      <div class="row">
        <input id="cell" type="range" min="3" max="64" step="1" value="8">
        <span class="num" id="cellVal">8</span>
      </div>
    </label>

    <label>
      <b>Радиус кружков (px)</b>
      <div class="row">
        <input id="radius" type="range" min="1" max="32" step="0.5" value="3">
        <span class="num" id="radiusVal">3.0</span>
      </div>
      <div class="hint">Держите &lt; половины шага</div>
    </label>

    <label>
      <b>Gamma</b>
      <div class="row">
        <input id="gamma" type="range" min="0.8" max="3.0" step="0.05" value="2.2">
        <span class="num" id="gammaVal">2.20</span>
      </div>
      <div class="hint">2.2 подходит для обычных sRGB изображений</div>
    </label>

    <div class="row" style="justify-content: space-between; margin-top: 8px;">
      <button id="download" disabled>Download PNG</button>
      <button id="reset" disabled>Сброс</button>
    </div>

    <p class="hint">Подложка в главном окне — шахматка, чтобы было видно прозрачность.</p>
  </aside>

  <main>
    <canvas id="c"></canvas>
  </main>

<script>
// ---------- WebGL2 setup ----------
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', { antialias: false, alpha: true, premultipliedAlpha: false });
if (!gl) { alert('Нужен браузер с поддержкой WebGL2'); }

const vsSrc = `#version 300 es
precision highp float;
out vec2 vUV;
void main(){
  // полноэкранный треугольник
  const vec2 pos[3] = vec2[3](vec2(-1.0,-1.0), vec2( 3.0,-1.0), vec2(-1.0, 3.0));
  vUV = pos[gl_VertexID] * 0.5 + 0.5;
  gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);
}`;

const fsSrc = `#version 300 es
precision highp float;
uniform sampler2D uImage;
uniform vec2  uResolution;
uniform float uCell;
uniform float uRadius;
uniform float uGamma;
in vec2  vUV;
out vec4  fragColor;

// 4x4 Bayer через таблицу индексов (int/битовые операции доступны в GLSL 300 es)
float bayer4(ivec2 ip){
  int x = ip.x & 3;
  int y = ip.y & 3;
  int idx = y*4 + x;
  const int t[16] = int[16](
    0, 8, 2,10,
   12, 4,14, 6,
    3,11, 1, 9,
   15, 7,13, 5
  );
  return (float(t[idx]) + 0.5) / 16.0;
}

float luma(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }

void main(){
  // читаем исходный цвет (растягиваем изображение на весь холст 1:1)
  vec3 src = texture(uImage, vUV).rgb;

  // яркость с гамма-разгибом
  float Y = luma(pow(src, vec3(1.0 / max(uGamma, 0.0001))));

  // индекс текущей ячейки решётки (в пикселях экрана)
  vec2 fragPx   = gl_FragCoord.xy;
  vec2 cellIdxF = floor(fragPx / uCell);
  ivec2 cellIdx = ivec2(cellIdxF);
  vec2 local    = ((fragPx / uCell) - cellIdxF - 0.5) * uCell;

  // дизеринг: тёмные области -> больше включённых точек
  float threshold = bayer4(cellIdx);
  float on = step(1.0 - Y, threshold);

  // жёсткий радиус + мягкий край ~1px
  float d = length(local);
  float edgeAA = smoothstep(uRadius, uRadius - 1.0, d);

  float alpha = on * edgeAA;
  fragColor = vec4(1.0, 1.0, 1.0, alpha); // белые точки на прозрачном фоне
}`;

function createShader(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(sh) || 'shader compile error');
  }
  return sh;
}
function createProgram(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(p) || 'program link error');
  }
  return p;
}

const program = createProgram(createShader(gl.VERTEX_SHADER, vsSrc), createShader(gl.FRAGMENT_SHADER, fsSrc));
gl.useProgram(program);

const loc = {
  uImage: gl.getUniformLocation(program, 'uImage'),
  uResolution: gl.getUniformLocation(program, 'uResolution'),
  uCell: gl.getUniformLocation(program, 'uCell'),
  uRadius: gl.getUniformLocation(program, 'uRadius'),
  uGamma: gl.getUniformLocation(program, 'uGamma'),
};

// ---------- Geometry (attribute-less) ----------
gl.bindVertexArray(gl.createVertexArray());

// ---------- Texture ----------
let tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// ---------- UI ----------
const $ = (id)=>document.getElementById(id);
const cell   = $('cell');
const radius = $('radius');
const gamma  = $('gamma');
const cellVal   = $('cellVal');
const radiusVal = $('radiusVal');
const gammaVal  = $('gammaVal');
const fileInput = $('file');
const btnDownload = $('download');
const btnReset = $('reset');

function syncLabels(){
  cellVal.textContent   = Number(cell.value).toFixed(0);
  radiusVal.textContent = Number(radius.value).toFixed(1);
  gammaVal.textContent  = Number(gamma.value).toFixed(2);
}
syncLabels();

[cell, radius, gamma].forEach(el => el.addEventListener('input', ()=>{
  // не даём радиусу превысить половину шага (аккуратнее выглядит)
  const maxR = Math.max(1, (Number(cell.value) * 0.49));
  if (Number(radius.value) > maxR) radius.value = maxR.toFixed(2);
  radius.max = Math.round(Number(cell.value)); // немного свободы
  syncLabels();
  draw();
}));

btnDownload.addEventListener('click', ()=>{
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'halftone_dots.png';
  a.click();
});

btnReset.addEventListener('click', ()=>{
  cell.value = 8; radius.value = 3; gamma.value = 2.2; syncLabels(); draw();
});

// ---------- Image loading ----------
let img = new Image();
img.onload = ()=>{
  // подгоняем размер canvas под картинку 1:1
  canvas.width  = img.naturalWidth;
  canvas.height = img.naturalHeight;

  // загружаем в текстуру
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // удобнее по UV
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE, img);

  // рисуем
  btnDownload.disabled = false;
  btnReset.disabled = false;
  draw();
};

fileInput.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  img.src = url;
});

function draw(){
  if (canvas.width === 0 || canvas.height === 0) return;

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0,0,0,0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(program);
  gl.uniform1i(loc.uImage, 0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);

  gl.uniform2f(loc.uResolution, canvas.width, canvas.height);
  gl.uniform1f(loc.uCell,   Number(cell.value));
  gl.uniform1f(loc.uRadius, Number(radius.value));
  gl.uniform1f(loc.uGamma,  Number(gamma.value));

  gl.drawArrays(gl.TRIANGLES, 0, 3); // полноэкранный треугольник
}
</script>
</body>
</html>
